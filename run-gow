#!/bin/bash

SCRIPT_NAME=$(basename "$0")
# shellcheck disable=SC2164
SCRIPT_DIR="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"
SCRIPT_ARGV=("$@")

MIN_COMPOSE_VERSION=2.6.0
readonly SCRIPT_NAME SCRIPT_DIR MIN_COMPOSE_VERSION

# Configuration values. These will be set based on the command-line arguments we get
launch_env=("env/base.env")
compose_files=("docker-compose.yml")
apps=()

gpu_type=none
quiet=false
headless=false
debug=false

function main {
    parse_cli SCRIPT_ARGV

    # which compose and environment files should we be using? this will depend
    # on command-line options as well as what app(s) we're launching
    if [ "$headless" = "true" ]; then
        launch_env+=("env/headless.env")
        compose_files+=("compose/headless.yml")
    else
        launch_env+=("env/host-desktop.env")
        compose_files+=("compose/host-destkop.yml")
    fi

    launch_env+=("env/$gpu_type.env")
    compose_files+=("compose/$gpu_type.yml")

    # if there's an app-specific env file, load it too
    for app in "${apps[@]}"; do
        launch_env+=("env/$app.env")
    done

    launch_env+=("user.env")

    if [ "$debug" = "true" ]; then
        print_debug_info
    else
        if ! check_compose_version; then
            echo_stderr "Your docker-compose is too old; please install v$MIN_COMPOSE_VERSION or later."
            exit 1
        fi

        # docker-compose >= v2.6.0 can't handle process substitution for the `--env-file` option :-(
        # but, it _does_ support loading variables from the process's environment.  So,
        # load the files we need before we execute docker-compose.
        set -o allexport
        for env_file in "${launch_env[@]}"; do
            if [ -f "$SCRIPT_DIR/$env_file" ]; then
                # shellcheck disable=1090
                source "$SCRIPT_DIR/$env_file"
            fi
        done
        set +o allexport

        echo_stderr "Running docker compose..."
        if [ "${#SCRIPT_ARGV}" -gt 0 ]; then
            eval "$(get_compose_cmd) ${SCRIPT_ARGV[*]}"
        else
            eval "$(get_compose_cmd) up"
        fi
    fi
}

# Print a usage message to the console
function usage() {
    quiet=false # always print usage, even if quiet is set
    echo_stderr "Launch the Games on Whales system"
    echo_stderr
    echo_stderr "Usage: $SCRIPT_NAME [options] [compose commands]"
    echo_stderr "Arguments after the last option will be passed directly to 'docker compose'."
    echo_stderr "For example, to launch the containers in the background, try:"
    echo_stderr "  $ $SCRIPT_NAME --app retroarch up -d"
    echo_stderr
    echo_stderr "Options:"
    echo_stderr "  -h, --help"
    echo_stderr "      Print this help text."
    echo_stderr
    echo_stderr "  -a, --app <app name>"
    echo_stderr "      Specify an application to launch. Can be used multiple times."
    echo_stderr
    echo_stderr "  -d, --debug"
    echo_stderr "      Print some extra debugging information before running Docker commands."
    echo_stderr
    echo_stderr "  -e, --env-file <file>"
    echo_stderr "      Specify an additional file of environment varibles to load before launching 'docker compose'."
    echo_stderr
    echo_stderr "  -g, --gpu <type>"
    echo_stderr "      Use this option to specify what type of GPU to use with Games on Whales. Not"
    echo_stderr "      all GPU types require this option (notably, AMD does not)."
    echo_stderr "      Possible types:"
    echo_stderr "        nvidia, intel"
    echo_stderr
    echo_stderr "  -q, --quiet"
    echo_stderr "      If set, this script will not produce any output of its own. This will not affect output from 'docker compose'."
    echo_stderr
    echo_stderr "  -x, --headless"
    echo_stderr "      If set, run in headless mode. Use this mode if your host does not have an Xorg server running on it."
    echo_stderr
    echo_stderr "  --"
    echo_stderr "      Signifies the end of options."
}

# Parse the command line args we were given
function parse_cli {
    local -n argv=$1

    if [ "${#argv}" -eq 0 ]; then
        usage
        exit 1
    fi

    local idx=0
    while [ "$idx" -le "${#argv[@]}" ]; do
        case "${argv[$idx]}" in
        -h|--help)
            usage
            exit 0
            ;;
        -a|--app)
            apps+=("${argv[$idx+1]}")
            idx=$((idx + 1))
            ;;
        -d|--debug)
            debug=true
            ;;
        -e|--env-file)
            launch_env+=("${argv[$idx+1]}")
            idx=$((idx + 1))
            ;;
        -g|--gpu)
            local type="${argv[$idx+1]}"
            if [ "$type" = "nvidia" ] || [ "$type" = "intel" ]; then
                gpu_type="$type"
            fi
            # even if they gave us one we don't recognize/need, skip over it
            idx=$((idx + 1))
            ;;
        -q|--quiet)
            quiet="true"
            ;;
        -x|--headless)
            headless="true"
            ;;
        --)
            break
            ;;
        -*)
            echo_stderr "Invalid option '${argv[$idx]}'." >&2
            usage
            exit 1
            ;;
        # non-option arguments should also stop processing; everything after will
        # be passed to docker compose.
        *)
            break
            ;;
        esac
        idx=$((idx + 1))
    done
    argv=( "${argv[@]:$idx}" )
}

# echo the given text to stderr, unless the "quiet" option is set
function echo_stderr() {
    local txt="$1"
    [ "$quiet" != "true" ] && echo "$txt" >&2
}

# Print out some extra debugging info. Currently, this is the list of
# environment variables we're loading, plus the transformed contents of each
# compose file.
function print_debug_info() {
    echo_stderr "Detected OS: $(os_type)"

    local version_status="✓"
    if ! check_compose_version; then
        version_status="✗"
    fi

    echo_stderr "Detected Compose version: $(get_compose_version) (min: $MIN_COMPOSE_VERSION) $version_status"
    echo_stderr ""

    local variable_re='^[[:space:]]*([[:alpha:]][[:alnum:]_]*)='

    # Print out the environment variables
    echo_stderr "Loading environment variables:"
    for env_file in "${launch_env[@]}"; do
        local full_file="$SCRIPT_DIR/$env_file"
        if [ -f "$full_file" ]; then
            while IFS= read -r line; do
                if [[ $line =~ $variable_re ]]; then
                    echo_stderr "    - ${line} (from $env_file)"
                fi
            done < "$full_file"
        fi
    done
    echo_stderr

    # Print out each transformed file
    for file in "${compose_files[@]}"; do
        if [ -f "$file" ]; then
            echo_stderr "Transformed file: $file"
            echo_stderr "$(transform_file "$file")"
            echo_stderr
        fi
    done

    for app in "${apps[@]}"; do
        app_file="compose/$app.yml"
        if [ -f "$app_file" ]; then
            echo_stderr "Transformed file: $app_file"
            echo_stderr "$(transform_file "$app_file")"
            echo_stderr
        fi
    done
}

# read the given text line by line and add the given padding string to the
# front of each line.
function pad_lines() {
    local text=$1
    local space=$2

    while IFS= read -r line; do
        echo "${space}${line}"
    done < <(printf '%s\n' "$text")
}

# Get a line suitable for inserting into an `env_file:` list in a docker
# compose file that will load whatever extra environment is necessary for the
# current gpu type, if such a file exists.
function get_gpu_env() {
    if [ -f "config/$gpu_type.env" ]; then
        echo "- config/${gpu_type}.env"
    fi
}

# what OS are we running on?  For most Linux distros, this will be whatever
# /etc/lsb-release or /etc/os-release says it is.  Unraid's just says
# "slackware" (which is true but not specific enough), so we use a different
# mechanism.
function os_type() {
    local os="unknown"
    if [ -f /etc/unraid-version ]; then
        os="unraid"
    elif [ -f /etc/lsb-release ]; then
        # shellcheck disable=1091
        os= "$(source /etc/lsb-release; echo "$DISTRIB_ID")"
    elif [ -f /etc/os-release ]; then
        # shellcheck disable=1091
        os="$(source /etc/os-release; echo "$ID")"
    fi

    # normalize os to be lower case
    echo "${os,,}"
}

# These are the mappings necessary to get nvidia Xorg drivers into the xorg
# container from the host.  They will only be used if $headless=true and
# $gpu_type=nvidia
declare -A xorg_driver
xorg_driver[unraid]=$(cat - <<END
- /usr/lib64/xorg/modules/drivers/nvidia_drv.so:/nvidia/xorg/nvidia_drv.so:ro
- /usr/lib64/xorg/modules/extensions/libglxserver_nvidia.so:/nvidia/xorg/libglxserver_nvidia.so:ro
END
)
xorg_driver[ubuntu]=$(cat - <<END
- /usr/lib/x86_64-linux-gnu/nvidia/xorg/:/nvidia/xorg/:ro
END
)
xorg_driver[arch]=$(cat - <<END
- /usr/lib/xorg/modules/drivers/nvidia_drv.so:/nvidia/xorg/nvidia_drv.so:ro
- /usr/lib/nvidia/xorg/libglxserver_nvidia.so:/nvidia/xorg/libglxserver_nvidia.so:ro
END
)
xorg_driver[debian]=$(cat - <<END
- /usr/lib/xorg/modules/drivers/nvidia_drv.so:/nvidia/xorg/nvidia_drv.so:ro
- /usr/lib/xorg/modules/extensions/libglxserver_nvidia.so:/nvidia/xorg/libglxserver_nvidia.so:ro
END
)

# Iterate through the given file and insert environment files and volume mounts
# as needed for the desired setup (headless, gpu type, etc)
function transform_file() {
    local file=$1

    local gpu_env_re='([[:space:]]+)# run-gow: gpu_env'
    local xorg_driver_re='([[:space:]]+)# run-gow: xorg_driver'

    while IFS= read -r line; do
        if [[ $line =~ $gpu_env_re ]]; then
            pad_lines "$(get_gpu_env)" "${BASH_REMATCH[1]}"
        elif [ "$gpu_type" = "nvidia" ] && [[ $line =~ $xorg_driver_re ]]; then
            pad_lines "${xorg_driver[$(os_type)]}" "${BASH_REMATCH[1]}"
        else
            echo "$line"
        fi
    done < "$file"
}

# return a command suitable for passing to 'eval' that will launch
# docker-compose with the correct configuration
function get_compose_cmd() {
    local cmd="docker compose "

    local yaml_files
    yaml_files=$(
        for file in "${compose_files[@]}"; do
            if [ -f "$file" ]; then
                echo -ne " -f <(transform_file $file)"
            fi
        done)
    yaml_files+=$(
        for app in "${apps[@]}"; do
            app_file="compose/$app.yml"
            if [ -f "$app_file" ]; then
                echo -ne " -f <(transform_file $app_file)"
            fi
        done)

    # cat -- <(cat $env_files)
    echo "$cmd --project-directory \"${SCRIPT_DIR}\" --project-name gow $yaml_files"
}

function get_compose_version() {
    local installed_version
    local compose_re='version v?([[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+)'
    if [[ "$(docker compose version)" =~ $compose_re ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo ""
    fi
}

# check that the installed version of docker-compose is new enough.
function check_compose_version() {
    local min_version installed_version version_string
    version_string=$(get_compose_version)

    if [[ "${version_string}" != "" ]]; then
        local IFS=.
        # shellcheck disable=2086
        printf -v installed_version %08d ${version_string}
        printf -v min_version %08d $MIN_COMPOSE_VERSION
        test "$installed_version" -ge $min_version
    else
        echo_stderr "Docker Compose was not found. Please install Docker Compose version $MIN_COMPOSE_VERSION or newer."
        false
    fi
}

main
